<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>自闭少年说</title>
  
  <subtitle>让我们一起开始自闭吧，呐~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://2yo.cc/"/>
  <updated>2020-01-11T07:47:03.694Z</updated>
  <id>https://2yo.cc/</id>
  
  <author>
    <name>自闭少年</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用SCF解决跨域、防盗链及HTTPS不能降级请求HTTP资源问题</title>
    <link href="https://2yo.cc/2020/01/11/%E5%88%A9%E7%94%A8SCF%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E3%80%81%E9%98%B2%E7%9B%97%E9%93%BE%E5%8F%8AHTTPS%E4%B8%8D%E8%83%BD%E9%99%8D%E7%BA%A7%E8%AF%B7%E6%B1%82HTTP%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98/"/>
    <id>https://2yo.cc/2020/01/11/%E5%88%A9%E7%94%A8SCF%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E3%80%81%E9%98%B2%E7%9B%97%E9%93%BE%E5%8F%8AHTTPS%E4%B8%8D%E8%83%BD%E9%99%8D%E7%BA%A7%E8%AF%B7%E6%B1%82HTTP%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98/</id>
    <published>2020-01-11T07:31:45.000Z</published>
    <updated>2020-01-11T07:47:03.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题阐述"><a href="#问题阐述" class="headerlink" title="问题阐述"></a>问题阐述</h2><p>在Web应用开发中，我们经常会遇到跨域，Refer防盗链以及HTTPS不能降级访问HTTP资源问题，一般的浏览器禁止了跨域请求且Ajax等方式不允许修改某些Header（如Refer和Orign），针对这三种情况我们一般只能通过代理访问来解决，即在自己的服务器上写一个代理小程序，再通过自己的域名访问这个小程序来解决。但是我们本就瘦小的带宽还要分出来一部分做代理着实让人不爽，这里分享一种方法，就是通过SCF来解决。</p><h2 id="何为SCF？"><a href="#何为SCF？" class="headerlink" title="何为SCF？"></a>何为SCF？</h2><p>SCF（Serverless Cloud Function），即无服务器云函数，是由腾讯在无服务器架构上的一种实现（阿里和华为也有，但名称不同，如称函数工作流），无服务器（Serverless）不是表示没有服务器，而表示当在使用 Serverless 时，无需关心底层资源，也无需登录服务器和优化服务器，只需关注最核心的代码片段，即可跳过复杂的、繁琐的基本工作。核心的代码片段完全由事件或者请求触发，平台根据请求自动平行调整服务资源。Serverless 拥有近乎无限的扩容能力，空闲时，不运行任何资源。代码运行无状态，可以轻易实现快速迭代、极速部署。</p><p>简而言之，就是提供了一个粘贴代码即可运行的环境，并且没有带宽约束以及“并发约束”，实现了弹性伸缩，无需担心服务器过载。</p><p>SCF目前分为三种，普通的云函数，以及Serverless2.0中的HTTP函数和服务型函数，后二者目前在内测，很荣幸拿到了HTTP函数的内测名额，普通的云函数基于事件驱动且配置麻烦限制也多，只能返回Json，如果要返回图片等媒体资源只能Base64编码后返回，大大降低了效率。而HTTP函数则不存在这种限制，它是完全基于HTTP Request 和HTTP Response的，但这并不意味着对返回是没有限制的：</p><h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h3><ul><li>当前 HTTP 函数目前仅支持 Nodejs 8.9，后续会支持多个 Runtime。</li><li>函数类型选定为 HTTP 后不可更改。</li><li>HTTP 函数不支持设置触发器。</li><li>HTTP 函数暂不支持版本和别名。</li><li>在 Request headers 中有以下限制：<ul><li>所有 key 和 value 的大小不得超过4KB。</li><li>path（含 query、params）不得超过4KB。</li><li>body 大小不超过6MB。</li></ul></li><li>在 Response headers 中有以下限制：<ul><li>所有 key 和 value 的大小不得超过4KB。</li><li>body 的大小不超过6MB。<br>对body的大小限制在6MB，但对于请求Json和图片等资源足够了，目前在内测阶段，说不准以后会有变动。</li></ul></li></ul><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>下面我们通过一个例子来讲述如何通过SCF来解决上述大坑。</p><p>我们知道著名插画站Pixiv（以下简称P站）由于某些不可名状的原因被GFW拒之墙外，但是它的图片服务器域名依旧还是可以访问的，不过对图片做了防盗链处理，必须要携带Refer才能访问，否则返回403，如下图：</p><p><img src="./403.png" alt="403"></p><p>那么我们首先去创建一个HTTP云函数，如下图：</p><p><img src="./scf1.png" alt="scf1"></p><p>点击下一步，有一些函数的基本信息：</p><p><img src="./scf.png" alt="scf2"></p><p>确认无误后我们点完成，这样我们就创建好了一个Hello world项目：</p><p><img src="./scf3.png" alt="helloword"></p><p>函数创建好之后就会为我们分配好一个公网域名，我们访问一下试试看：</p><p><img src="./scf4.png" alt="scf4"></p><p>基本的流程完毕了，剩下的就是写代码了，P站的防盗链机制是检查Refer，那么只要伪造Header就可以了，我已经写好一个了，代码如下（不是专业搞前端的，JS写的很烂，大佬轻喷:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">const fetch &#x3D; require(&#39;node-fetch&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">const app &#x3D; require(&#39;express&#39;)();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">app.get(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    pic &#x3D; req.query.url</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    if (pic &#x3D;&#x3D;&#x3D; undefined || pic.length &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 必须要有图片url，否则我们返回400</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        res.status(400).json(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            &#39;code&#39;: -1,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            &#39;msg&#39;: &#39;URL is a necessary parameter.&#39;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125; else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        fetch(pic, &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            headers: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                &#39;Referer&#39;: &#39;https:&#x2F;&#x2F;pixiv.net&#39;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        &#125;).then(function(response) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            if (!response.ok) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                res.set(&#39;Content-Type&#39;, &#39;application&#x2F;json&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                res.status(500).json(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                    &#39;code&#39;: -1,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">                    &#39;status&#39;: &#39;error&#39;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">                &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            &#125; else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">                res.set(&#39;Content-Type&#39;, &#39;image&#x2F;jpeg&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">            returnresponse</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        &#125;).then(response &#x3D;&gt; response.buffer()).then(response &#x3D;&gt; res.status(200).send(response)).then().</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        catch(e &#x3D;&gt; console.log(&#39;Msg&#39; + e));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">exports.main_handler &#x3D; app</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;app.listen(8080)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;app.listen(8080)</span></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>SCF已经支持其他环境</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p>腾讯SCF官方手册</p>]]></content>
    
    <summary type="html">
    
      使用SCF解决跨域、Refer防盗链及HTTPS不能降级请求HTTP资源问题
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>一次自动提交脚本的经历</title>
    <link href="https://2yo.cc/2020/01/11/%E4%B8%80%E6%AC%A1%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E8%84%9A%E6%9C%AC%E7%9A%84%E7%BB%8F%E5%8E%86/"/>
    <id>https://2yo.cc/2020/01/11/%E4%B8%80%E6%AC%A1%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E8%84%9A%E6%9C%AC%E7%9A%84%E7%BB%8F%E5%8E%86/</id>
    <published>2020-01-11T06:42:01.000Z</published>
    <updated>2020-01-11T07:03:15.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>事情的起因是这样的，最近需要在某系统上注册一个账号，结果怎么都收不到邮件，试了有十几次，然后我去打听了一下，所有人都是这样，少则十几次才能收到，多则几十次，便萌生了写脚本自动提交的想法。</p><h2 id="分析逻辑"><a href="#分析逻辑" class="headerlink" title="分析逻辑"></a>分析逻辑</h2><p>第一步当然要分析逻辑，这也是最重要的一步，好在这个系统比较简单，没一会儿就分析好了。先看一下表单：<br><img src="./%E6%BF%80%E6%B4%BB%E4%B8%BB%E9%A1%B5.png" alt="激活主页"><br>两个输入框分别输入邮件和验证码，我们在看下源码：<br><img src="./form.png" alt="表单数据"><br>这个form没有action属性，是通过checkForm方法提交的，我们再来看下checkForm方法：<br><img src="./check.png" alt="check"><br>还有一些代码被我删减掉了，只留下最主要的代码，首先将表单数据post到后台，如果后台的返回body为空串，则跳转到第二个网址，否则提示错误信息。至此我们已经将逻辑分析好了，我们只要模拟这段js代码的逻辑向后台提交数据。</p><h2 id="验证码识别"><a href="#验证码识别" class="headerlink" title="验证码识别"></a>验证码识别</h2><p>这个系统的验证码图形并不复杂，干扰线不严重，数字整体也没有太大扭曲，所以使用Tesseract就足够了，验证码识别的准确率不需要百分之百但也不能太低，百分之六十以上就不错了。为了提高准确率，我们先要对图片做一些简单的处理。</p><h3 id="灰度化处理"><a href="#灰度化处理" class="headerlink" title="灰度化处理"></a>灰度化处理</h3><p>第一步是将验证码处理为灰度图片，下图为处理好的例子，左侧为原图像，右侧为灰度图像。<br><img src="./merge.png" alt="merge"></p><h3 id="二值化处理"><a href="#二值化处理" class="headerlink" title="二值化处理"></a>二值化处理</h3><p>第二步将处理好的灰度图像二值化，二值化的阈值选择可能比较难选择，需要多次试验选择一个较优的阈值，下面为不同阈值对应的二值化图像：<br><img src="./thresh.jpg" alt="thresh"><br>阈值130是一个比较好的选择，阈值100有些数字已经看不清了，200又没能很好的去除干扰线。</p><h3 id="Tesseract识别"><a href="#Tesseract识别" class="headerlink" title="Tesseract识别"></a>Tesseract识别</h3><p>第三步用Tesseract识别二值化图像就可以了。<br><img src="./result.png" alt="result"></p><p>5个中对了4个，就结果来说比较满意了。另外，不知您发现没有，它这个验证码每个数字的位置是固定的。。。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>代码被我删掉了，我怕铁憨憨把人家系统弄瘫痪。。。</p>]]></content>
    
    <summary type="html">
    
      某系统的邮件验证系统有问题,写了个自动提交的脚本~
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>博客迁移到hexo啦</title>
    <link href="https://2yo.cc/2019/12/17/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/"/>
    <id>https://2yo.cc/2019/12/17/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/</id>
    <published>2019-12-17T03:38:20.000Z</published>
    <updated>2020-01-11T07:40:26.791Z</updated>
    
    <content type="html"><![CDATA[<p>由于.cc域名暂时不能备案又不舍得丢，只好将博客迁移到Gitpage，最近会将一些有价值的文章从原博客上迁移过来，WordPress有些过于方便导致最近的文章有些水，这次就打算好好写一些长文了。并且打算用空出的服务器开发出一些小工具来供朋友们使用，毕竟一直白嫖API也怪不好意思的，哈哈哈。</p><p>W</p>]]></content>
    
    <summary type="html">
    
      由于某些原因,把博客迁移到hexo啦~
    
    </summary>
    
    
    
      <category term="Other" scheme="https://2yo.cc/tags/Other/"/>
    
  </entry>
  
</feed>
